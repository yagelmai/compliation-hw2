%{ 
	#include <iostream>
	#include "parser.tab.hpp"	
	#include <stdlib.h>
	#include <stdio.h>
	#include "output.hpp"

	using namespace std;
	int yylex();
	extern int yylineno;
	void yyerror(const char*);
%}


%right ASSIGN
%left OR
%left AND
%left EQUALITY
%nonassoc RELATIONAL
%left ADDITIVE
%left MULTIPLICATIVE
%right NOT
%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token TRUE
%token FALSE
%token RETURN
%token IF
%nonassoc IFPREC
%left ELSE
%token WHILE
%token BREAK
%token CONTINUE
%token PRECOND
%token SC
%token COMMA
%token LBRACE
%token RBRACE
%token ID
%token NUM
%token STRING
%token LPAREN
%token RPAREN
%token RELOP


%%


Prog:               Funcs               										{printProductionRule(1);}
;

Funcs:              /* epsilon */       										{printProductionRule(2);}
                    | FuncDecl Funcs    										{printProductionRule(3);}
;

FuncDecl:           RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE   {printProductionRule(4);}
;

RetType:            Type                										{printProductionRule(5);}
                    |  VOID             										{printProductionRule(6);}
;

Formals:            /* epsilon */       										{printProductionRule(7);}
                    | FormalsList       										{printProductionRule(8);}
;

FormalsList:        FormalDecl          										{printProductionRule(9);}
                    | FormalDecl COMMA FormalsList  							{printProductionRule(10);}
;

FormalDecl:         Type ID         				 							{printProductionRule(11);}
;

Statements:         Statement           										{printProductionRule(12);}
                    | Statements Statement  									{printProductionRule(13);}
;

Statement:          LBRACE Statements RBRACE    								{printProductionRule(14);}
                    | Type ID SC 											    {printProductionRule(15);}
                    | Type ID ASSIGN Exp SC  									{printProductionRule(16);}
                    | ID ASSIGN Exp SC  										{printProductionRule(17);}
                    | Call SC           										{printProductionRule(18);}
                    | RETURN SC         										{printProductionRule(19);}
                    | RETURN Exp SC     										{printProductionRule(20);}
                    | IF LPAREN Exp RPAREN Statement    								{printProductionRule(21);}
                    | IF LPAREN Exp RPAREN Statement ELSE Statement 							{printProductionRule(22);}
                    | WHILE LPAREN Exp RPAREN Statement 								{printProductionRule(23);}
                    | BREAK SC          										{printProductionRule(24);}
                    | CONTINUE SC       										{printProductionRule(25);}
;

Call:               ID LPAREN ExpList RPAREN    								{printProductionRule(26);}
                    | ID LPAREN RPAREN          								{printProductionRule(27);}
;

ExpList:            Exp                         								{printProductionRule(28);}
                    | Exp COMMA ExpList         								{printProductionRule(30);}
;

Type:               INT                         								{printProductionRule(31);}
                    | BYTE                      								{printProductionRule(32);}
                    | BOOL                      								{printProductionRule(33);}
;

Exp:                LPAREN Exp RPAREN           								{printProductionRule(34);}
                    | ID                        								{printProductionRule(36);}
                    | Call                      								{printProductionRule(37);}
                    | NUM                       								{printProductionRule(38);}
                    | NUM B                     								{printProductionRule(39);}
                    | STRING                    								{printProductionRule(40);}
                    | TRUE                      								{printProductionRule(41);}
                    | FALSE                     								{printProductionRule(42);}
                    | NOT Exp                   								{printProductionRule(43);}
                    | Exp AND Exp               								{printProductionRule(44);}
                    | Exp OR Exp                								{printProductionRule(45);}
                    | Exp RELOP Exp             								{printProductionRule(46);}
                    | LPAREN Type RPAREN Exp    								{printProductionRule(46);}
;

%%

void yyerror(const char*)											{errorSyn(yylineno); exit(1);}

int main() 										{
	return yyparse();
}
