%{ 
	#include <iostream>
	#include "parser.tab.hpp"	
	#include <stdlib.h>
	#include <stdio.h>
	#include "output.hpp"
    using namespace output;
	int yylex();
	extern int yylineno;
	void yyerror(const char*);
%}

//
%right ASSIGN
%left OR
%left AND
%left RELOP
%left RBINOP
%left LBINOP
%right NOT
%left LPAREN
%left RPAREN
%nonassoc VOID
%nonassoc INT
%nonassoc BYTE
%nonassoc B
%nonassoc BOOL
%nonassoc TRUE
%nonassoc FALSE
%nonassoc RETURN
%nonassoc IF
%nonassoc ELSE
%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE
%nonassoc SC
%nonassoc COMMA
%nonassoc LBRACE
%nonassoc RBRACE
%nonassoc ID
%nonassoc NUM
%nonassoc STRING


%%


Prog:               Funcs               										{printProductionRule(1);}
;

Funcs:              /* epsilon */       										{printProductionRule(2);}
                    | FuncDecl Funcs    										{printProductionRule(3);}
;

FuncDecl:           RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE   {printProductionRule(4);}
;

RetType:            Type                										{printProductionRule(5);}
                    |  VOID             										{printProductionRule(6);}
;

Formals:            /* epsilon */       										{printProductionRule(7);}
                    | FormalsList       										{printProductionRule(8);}
;

FormalsList:        FormalDecl          										{printProductionRule(9);}
                    | FormalDecl COMMA FormalsList  							{printProductionRule(10);}
;

FormalDecl:         Type ID         				 							{printProductionRule(11);}
;

Statements:         Statement           										{printProductionRule(12);}
                    | Statements Statement  									{printProductionRule(13);}
;

Statement:          open_statement
                    | closed_statement
;
open_statement:     IF LPAREN Exp RPAREN simple_statement                       {printProductionRule(21);}
                    | IF LPAREN Exp RPAREN open_statement                       {printProductionRule(21);}
                    | IF LPAREN Exp RPAREN closed_statement ELSE open_statement {printProductionRule(22);}
                    | WHILE LPAREN Exp RPAREN open_statement                    {printProductionRule(23);}
;
closed_statement:   simple_statement
                    | IF LPAREN Exp RPAREN closed_statement ELSE closed_statement{printProductionRule(22);}
                    | WHILE LPAREN Exp RPAREN closed_statement                  {printProductionRule(23);}
;
simple_statement:   LBRACE Statements RBRACE    								{printProductionRule(14);}
                    | Type ID SC 											    {printProductionRule(15);}
                    | Type ID ASSIGN Exp SC  									{printProductionRule(16);}
                    | ID ASSIGN Exp SC  										{printProductionRule(17);}
                    | Call SC           										{printProductionRule(18);}
                    | RETURN SC         										{printProductionRule(19);}
                    | RETURN Exp SC     										{printProductionRule(20);}
                    | BREAK SC          										{printProductionRule(24);}
                    | CONTINUE SC       										{printProductionRule(25);}

Call:               ID LPAREN ExpList RPAREN    								{printProductionRule(26);}
                    | ID LPAREN RPAREN          								{printProductionRule(27);}
;

ExpList:            Exp                         								{printProductionRule(28);}
                    | Exp COMMA ExpList         								{printProductionRule(29);}
;

Type:               INT                         								{printProductionRule(30);}
                    | BYTE                      								{printProductionRule(31);}
                    | BOOL                      								{printProductionRule(32);}
;

Exp:                LPAREN Exp RPAREN           								{printProductionRule(33);}
                    | Exp LBINOP Exp           								    {printProductionRule(34);}
                    | Exp RBINOP Exp           								    {printProductionRule(34);}
                    | ID                        								{printProductionRule(35);}
                    | Call                      								{printProductionRule(36);}
                    | NUM                       								{printProductionRule(37);}
                    | NUM B                     								{printProductionRule(38);}
                    | STRING                    								{printProductionRule(39);}
                    | TRUE                      								{printProductionRule(40);}
                    | FALSE                     								{printProductionRule(41);}
                    | NOT Exp                   								{printProductionRule(42);}
                    | Exp AND Exp               								{printProductionRule(43);}
                    | Exp OR Exp                								{printProductionRule(44);}
                    | Exp RELOP Exp             								{printProductionRule(45);}
                    | LPAREN Type RPAREN Exp    								{printProductionRule(46);}
;

%%

void yyerror(const char*)											{errorSyn(yylineno); exit(1);}

int main() 										{
	return yyparse();
}
